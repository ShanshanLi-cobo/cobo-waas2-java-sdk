/*
 * Cobo Wallet as a Service 2.0
 *
 * Contact: help@cobo.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.cobo.waas2.model;

import java.util.Objects;
import com.cobo.waas2.model.AcquiringType;
import com.cobo.waas2.model.TransactionBlockInfo;
import com.cobo.waas2.model.TransactionDestination;
import com.cobo.waas2.model.TransactionFee;
import com.cobo.waas2.model.TransactionFuelingInfo;
import com.cobo.waas2.model.TransactionInitiatorType;
import com.cobo.waas2.model.TransactionRawTxInfo;
import com.cobo.waas2.model.TransactionReplacement;
import com.cobo.waas2.model.TransactionResult;
import com.cobo.waas2.model.TransactionSource;
import com.cobo.waas2.model.TransactionStatus;
import com.cobo.waas2.model.TransactionSubStatus;
import com.cobo.waas2.model.TransactionType;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.cobo.waas2.JSON;

/**
 * PaymentTransactionEventData
 */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen", 
    comments = "Generator version: 7.6.0"
)
public class PaymentTransactionEventData {
  /**
   *  The data type of the event. - &#x60;Transaction&#x60;: The transaction event data. - &#x60;TSSRequest&#x60;: The TSS request event data. - &#x60;Addresses&#x60;: The addresses event data. - &#x60;WalletInfo&#x60;: The wallet information event data. - &#x60;MPCVault&#x60;: The MPC vault event data. - &#x60;Chains&#x60;: The enabled chain event data. - &#x60;Tokens&#x60;: The enabled token event data. - &#x60;TokenListing&#x60;: The token listing event data.        - &#x60;PaymentOrder&#x60;: The payment order event data. - &#x60;PaymentRefund&#x60;: The payment refund event data. - &#x60;PaymentSettlement&#x60;: The payment settlement event data. - &#x60;PaymentTransaction&#x60;: The payment transaction event data. - &#x60;PaymentAddressUpdate&#x60;: The top-up address update event data. - &#x60;BalanceUpdateInfo&#x60;: The balance update event data. - &#x60;SuspendedToken&#x60;: The token suspension event data. - &#x60;ComplianceDisposition&#x60;: The compliance disposition event data. - &#x60;ComplianceKytScreenings&#x60;: The compliance KYT screenings event data.
   */
  @JsonAdapter(DataTypeEnum.Adapter.class)
  public enum DataTypeEnum {
    TRANSACTION("Transaction"),
    
    TSSREQUEST("TSSRequest"),
    
    ADDRESSES("Addresses"),
    
    WALLETINFO("WalletInfo"),
    
    MPCVAULT("MPCVault"),
    
    CHAINS("Chains"),
    
    TOKENS("Tokens"),
    
    TOKENLISTING("TokenListing"),
    
    PAYMENTORDER("PaymentOrder"),
    
    PAYMENTREFUND("PaymentRefund"),
    
    PAYMENTSETTLEMENT("PaymentSettlement"),
    
    PAYMENTTRANSACTION("PaymentTransaction"),
    
    PAYMENTADDRESSUPDATE("PaymentAddressUpdate"),
    
    BALANCEUPDATEINFO("BalanceUpdateInfo"),
    
    SUSPENDEDTOKEN("SuspendedToken"),
    
    COMPLIANCEDISPOSITION("ComplianceDisposition"),
    
    COMPLIANCEKYTSCREENINGS("ComplianceKytScreenings");

    private String value;

    DataTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DataTypeEnum fromValue(String value) {
      for (DataTypeEnum b : DataTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DataTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DataTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DataTypeEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DataTypeEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DATA_TYPE = "data_type";
  @SerializedName(SERIALIZED_NAME_DATA_TYPE)
  private DataTypeEnum dataType;

  public static final String SERIALIZED_NAME_TRANSACTION_ID = "transaction_id";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_ID)
  private UUID transactionId;

  public static final String SERIALIZED_NAME_COBO_ID = "cobo_id";
  @SerializedName(SERIALIZED_NAME_COBO_ID)
  private String coboId;

  public static final String SERIALIZED_NAME_REQUEST_ID = "request_id";
  @SerializedName(SERIALIZED_NAME_REQUEST_ID)
  private String requestId;

  public static final String SERIALIZED_NAME_WALLET_ID = "wallet_id";
  @SerializedName(SERIALIZED_NAME_WALLET_ID)
  private String walletId;

  public static final String SERIALIZED_NAME_TYPE = "type";
  @SerializedName(SERIALIZED_NAME_TYPE)
  private TransactionType type;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  private TransactionStatus status;

  public static final String SERIALIZED_NAME_SUB_STATUS = "sub_status";
  @SerializedName(SERIALIZED_NAME_SUB_STATUS)
  private TransactionSubStatus subStatus;

  public static final String SERIALIZED_NAME_FAILED_REASON = "failed_reason";
  @SerializedName(SERIALIZED_NAME_FAILED_REASON)
  private String failedReason;

  public static final String SERIALIZED_NAME_CHAIN_ID = "chain_id";
  @SerializedName(SERIALIZED_NAME_CHAIN_ID)
  private String chainId;

  public static final String SERIALIZED_NAME_TOKEN_ID = "token_id";
  @SerializedName(SERIALIZED_NAME_TOKEN_ID)
  private String tokenId;

  public static final String SERIALIZED_NAME_ASSET_ID = "asset_id";
  @SerializedName(SERIALIZED_NAME_ASSET_ID)
  private String assetId;

  public static final String SERIALIZED_NAME_SOURCE = "source";
  @SerializedName(SERIALIZED_NAME_SOURCE)
  private TransactionSource source;

  public static final String SERIALIZED_NAME_DESTINATION = "destination";
  @SerializedName(SERIALIZED_NAME_DESTINATION)
  private TransactionDestination destination;

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  private TransactionResult result;

  public static final String SERIALIZED_NAME_FEE = "fee";
  @SerializedName(SERIALIZED_NAME_FEE)
  private TransactionFee fee;

  public static final String SERIALIZED_NAME_INITIATOR = "initiator";
  @SerializedName(SERIALIZED_NAME_INITIATOR)
  private String initiator;

  public static final String SERIALIZED_NAME_INITIATOR_TYPE = "initiator_type";
  @SerializedName(SERIALIZED_NAME_INITIATOR_TYPE)
  private TransactionInitiatorType initiatorType;

  public static final String SERIALIZED_NAME_CONFIRMED_NUM = "confirmed_num";
  @SerializedName(SERIALIZED_NAME_CONFIRMED_NUM)
  private Integer confirmedNum;

  public static final String SERIALIZED_NAME_CONFIRMING_THRESHOLD = "confirming_threshold";
  @SerializedName(SERIALIZED_NAME_CONFIRMING_THRESHOLD)
  private Integer confirmingThreshold;

  public static final String SERIALIZED_NAME_TRANSACTION_HASH = "transaction_hash";
  @SerializedName(SERIALIZED_NAME_TRANSACTION_HASH)
  private String transactionHash;

  public static final String SERIALIZED_NAME_BLOCK_INFO = "block_info";
  @SerializedName(SERIALIZED_NAME_BLOCK_INFO)
  private TransactionBlockInfo blockInfo;

  public static final String SERIALIZED_NAME_RAW_TX_INFO = "raw_tx_info";
  @SerializedName(SERIALIZED_NAME_RAW_TX_INFO)
  private TransactionRawTxInfo rawTxInfo;

  public static final String SERIALIZED_NAME_REPLACEMENT = "replacement";
  @SerializedName(SERIALIZED_NAME_REPLACEMENT)
  private TransactionReplacement replacement;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  private List<String> category = new ArrayList<>();

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_IS_LOOP = "is_loop";
  @SerializedName(SERIALIZED_NAME_IS_LOOP)
  private Boolean isLoop;

  public static final String SERIALIZED_NAME_COBO_CATEGORY = "cobo_category";
  @SerializedName(SERIALIZED_NAME_COBO_CATEGORY)
  private List<String> coboCategory = new ArrayList<>();

  public static final String SERIALIZED_NAME_EXTRA = "extra";
  @SerializedName(SERIALIZED_NAME_EXTRA)
  private List<String> extra = new ArrayList<>();

  public static final String SERIALIZED_NAME_FUELING_INFO = "fueling_info";
  @SerializedName(SERIALIZED_NAME_FUELING_INFO)
  private TransactionFuelingInfo fuelingInfo;

  public static final String SERIALIZED_NAME_CREATED_TIMESTAMP = "created_timestamp";
  @SerializedName(SERIALIZED_NAME_CREATED_TIMESTAMP)
  private Long createdTimestamp;

  public static final String SERIALIZED_NAME_UPDATED_TIMESTAMP = "updated_timestamp";
  @SerializedName(SERIALIZED_NAME_UPDATED_TIMESTAMP)
  private Long updatedTimestamp;

  public static final String SERIALIZED_NAME_ACQUIRING_TYPE = "acquiring_type";
  @SerializedName(SERIALIZED_NAME_ACQUIRING_TYPE)
  private AcquiringType acquiringType;

  public static final String SERIALIZED_NAME_ORDER_ID = "order_id";
  @SerializedName(SERIALIZED_NAME_ORDER_ID)
  private String orderId;

  public static final String SERIALIZED_NAME_PSP_ORDER_CODE = "psp_order_code";
  @SerializedName(SERIALIZED_NAME_PSP_ORDER_CODE)
  private String pspOrderCode;

  public static final String SERIALIZED_NAME_PAYER_ID = "payer_id";
  @SerializedName(SERIALIZED_NAME_PAYER_ID)
  private String payerId;

  public static final String SERIALIZED_NAME_CUSTOM_PAYER_ID = "custom_payer_id";
  @SerializedName(SERIALIZED_NAME_CUSTOM_PAYER_ID)
  private String customPayerId;

  public PaymentTransactionEventData() {
  }

  public PaymentTransactionEventData dataType(DataTypeEnum dataType) {
    this.dataType = dataType;
    return this;
  }

   /**
   *  The data type of the event. - &#x60;Transaction&#x60;: The transaction event data. - &#x60;TSSRequest&#x60;: The TSS request event data. - &#x60;Addresses&#x60;: The addresses event data. - &#x60;WalletInfo&#x60;: The wallet information event data. - &#x60;MPCVault&#x60;: The MPC vault event data. - &#x60;Chains&#x60;: The enabled chain event data. - &#x60;Tokens&#x60;: The enabled token event data. - &#x60;TokenListing&#x60;: The token listing event data.        - &#x60;PaymentOrder&#x60;: The payment order event data. - &#x60;PaymentRefund&#x60;: The payment refund event data. - &#x60;PaymentSettlement&#x60;: The payment settlement event data. - &#x60;PaymentTransaction&#x60;: The payment transaction event data. - &#x60;PaymentAddressUpdate&#x60;: The top-up address update event data. - &#x60;BalanceUpdateInfo&#x60;: The balance update event data. - &#x60;SuspendedToken&#x60;: The token suspension event data. - &#x60;ComplianceDisposition&#x60;: The compliance disposition event data. - &#x60;ComplianceKytScreenings&#x60;: The compliance KYT screenings event data.
   * @return dataType
  **/
  @javax.annotation.Nonnull
  public DataTypeEnum getDataType() {
    return dataType;
  }

  public void setDataType(DataTypeEnum dataType) {
    this.dataType = dataType;
  }


  public PaymentTransactionEventData transactionId(UUID transactionId) {
    this.transactionId = transactionId;
    return this;
  }

   /**
   * The transaction ID.
   * @return transactionId
  **/
  @javax.annotation.Nonnull
  public UUID getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(UUID transactionId) {
    this.transactionId = transactionId;
  }


  public PaymentTransactionEventData coboId(String coboId) {
    this.coboId = coboId;
    return this;
  }

   /**
   * The Cobo ID, which can be used to track a transaction.
   * @return coboId
  **/
  @javax.annotation.Nullable
  public String getCoboId() {
    return coboId;
  }

  public void setCoboId(String coboId) {
    this.coboId = coboId;
  }


  public PaymentTransactionEventData requestId(String requestId) {
    this.requestId = requestId;
    return this;
  }

   /**
   * The request ID that is used to track a transaction request. The request ID is provided by you and must be unique within your organization.
   * @return requestId
  **/
  @javax.annotation.Nullable
  public String getRequestId() {
    return requestId;
  }

  public void setRequestId(String requestId) {
    this.requestId = requestId;
  }


  public PaymentTransactionEventData walletId(String walletId) {
    this.walletId = walletId;
    return this;
  }

   /**
   * For deposit transactions, this property represents the wallet ID of the transaction destination. For transactions of other types, this property represents the wallet ID of the transaction source.
   * @return walletId
  **/
  @javax.annotation.Nonnull
  public String getWalletId() {
    return walletId;
  }

  public void setWalletId(String walletId) {
    this.walletId = walletId;
  }


  public PaymentTransactionEventData type(TransactionType type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @javax.annotation.Nullable
  public TransactionType getType() {
    return type;
  }

  public void setType(TransactionType type) {
    this.type = type;
  }


  public PaymentTransactionEventData status(TransactionStatus status) {
    this.status = status;
    return this;
  }

   /**
   * Get status
   * @return status
  **/
  @javax.annotation.Nonnull
  public TransactionStatus getStatus() {
    return status;
  }

  public void setStatus(TransactionStatus status) {
    this.status = status;
  }


  public PaymentTransactionEventData subStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
    return this;
  }

   /**
   * Get subStatus
   * @return subStatus
  **/
  @javax.annotation.Nullable
  public TransactionSubStatus getSubStatus() {
    return subStatus;
  }

  public void setSubStatus(TransactionSubStatus subStatus) {
    this.subStatus = subStatus;
  }


  public PaymentTransactionEventData failedReason(String failedReason) {
    this.failedReason = failedReason;
    return this;
  }

   /**
   * (This property is applicable to approval failures and signature failures only) The reason why the transaction failed.
   * @return failedReason
  **/
  @javax.annotation.Nullable
  public String getFailedReason() {
    return failedReason;
  }

  public void setFailedReason(String failedReason) {
    this.failedReason = failedReason;
  }


  public PaymentTransactionEventData chainId(String chainId) {
    this.chainId = chainId;
    return this;
  }

   /**
   * The chain ID, which is the unique identifier of a blockchain. You can retrieve the IDs of all the chains you can use by calling [List enabled chains](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-chains).
   * @return chainId
  **/
  @javax.annotation.Nullable
  public String getChainId() {
    return chainId;
  }

  public void setChainId(String chainId) {
    this.chainId = chainId;
  }


  public PaymentTransactionEventData tokenId(String tokenId) {
    this.tokenId = tokenId;
    return this;
  }

   /**
   * The token ID, which is the unique identifier of a token. You can retrieve the IDs of all the tokens you can use by calling [List enabled tokens](https://www.cobo.com/developers/v2/api-references/wallets/list-enabled-tokens).
   * @return tokenId
  **/
  @javax.annotation.Nullable
  public String getTokenId() {
    return tokenId;
  }

  public void setTokenId(String tokenId) {
    this.tokenId = tokenId;
  }


  public PaymentTransactionEventData assetId(String assetId) {
    this.assetId = assetId;
    return this;
  }

   /**
   * (This concept applies to Exchange Wallets only) The asset ID. An asset ID is the unique identifier of the asset held within your linked exchange account.
   * @return assetId
  **/
  @javax.annotation.Nullable
  public String getAssetId() {
    return assetId;
  }

  public void setAssetId(String assetId) {
    this.assetId = assetId;
  }


  public PaymentTransactionEventData source(TransactionSource source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @javax.annotation.Nonnull
  public TransactionSource getSource() {
    return source;
  }

  public void setSource(TransactionSource source) {
    this.source = source;
  }


  public PaymentTransactionEventData destination(TransactionDestination destination) {
    this.destination = destination;
    return this;
  }

   /**
   * Get destination
   * @return destination
  **/
  @javax.annotation.Nonnull
  public TransactionDestination getDestination() {
    return destination;
  }

  public void setDestination(TransactionDestination destination) {
    this.destination = destination;
  }


  public PaymentTransactionEventData result(TransactionResult result) {
    this.result = result;
    return this;
  }

   /**
   * Get result
   * @return result
  **/
  @javax.annotation.Nullable
  public TransactionResult getResult() {
    return result;
  }

  public void setResult(TransactionResult result) {
    this.result = result;
  }


  public PaymentTransactionEventData fee(TransactionFee fee) {
    this.fee = fee;
    return this;
  }

   /**
   * Get fee
   * @return fee
  **/
  @javax.annotation.Nullable
  public TransactionFee getFee() {
    return fee;
  }

  public void setFee(TransactionFee fee) {
    this.fee = fee;
  }


  public PaymentTransactionEventData initiator(String initiator) {
    this.initiator = initiator;
    return this;
  }

   /**
   * The transaction initiator.
   * @return initiator
  **/
  @javax.annotation.Nullable
  public String getInitiator() {
    return initiator;
  }

  public void setInitiator(String initiator) {
    this.initiator = initiator;
  }


  public PaymentTransactionEventData initiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
    return this;
  }

   /**
   * Get initiatorType
   * @return initiatorType
  **/
  @javax.annotation.Nonnull
  public TransactionInitiatorType getInitiatorType() {
    return initiatorType;
  }

  public void setInitiatorType(TransactionInitiatorType initiatorType) {
    this.initiatorType = initiatorType;
  }


  public PaymentTransactionEventData confirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
    return this;
  }

   /**
   * The number of confirmations this transaction has received.
   * @return confirmedNum
  **/
  @javax.annotation.Nullable
  public Integer getConfirmedNum() {
    return confirmedNum;
  }

  public void setConfirmedNum(Integer confirmedNum) {
    this.confirmedNum = confirmedNum;
  }


  public PaymentTransactionEventData confirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
    return this;
  }

   /**
   * The minimum number of confirmations required to deem a transaction secure. The common threshold is 6 for a Bitcoin transaction.
   * @return confirmingThreshold
  **/
  @javax.annotation.Nullable
  public Integer getConfirmingThreshold() {
    return confirmingThreshold;
  }

  public void setConfirmingThreshold(Integer confirmingThreshold) {
    this.confirmingThreshold = confirmingThreshold;
  }


  public PaymentTransactionEventData transactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
    return this;
  }

   /**
   * The transaction hash.
   * @return transactionHash
  **/
  @javax.annotation.Nullable
  public String getTransactionHash() {
    return transactionHash;
  }

  public void setTransactionHash(String transactionHash) {
    this.transactionHash = transactionHash;
  }


  public PaymentTransactionEventData blockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
    return this;
  }

   /**
   * Get blockInfo
   * @return blockInfo
  **/
  @javax.annotation.Nullable
  public TransactionBlockInfo getBlockInfo() {
    return blockInfo;
  }

  public void setBlockInfo(TransactionBlockInfo blockInfo) {
    this.blockInfo = blockInfo;
  }


  public PaymentTransactionEventData rawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
    return this;
  }

   /**
   * Get rawTxInfo
   * @return rawTxInfo
  **/
  @javax.annotation.Nullable
  public TransactionRawTxInfo getRawTxInfo() {
    return rawTxInfo;
  }

  public void setRawTxInfo(TransactionRawTxInfo rawTxInfo) {
    this.rawTxInfo = rawTxInfo;
  }


  public PaymentTransactionEventData replacement(TransactionReplacement replacement) {
    this.replacement = replacement;
    return this;
  }

   /**
   * Get replacement
   * @return replacement
  **/
  @javax.annotation.Nullable
  public TransactionReplacement getReplacement() {
    return replacement;
  }

  public void setReplacement(TransactionReplacement replacement) {
    this.replacement = replacement;
  }


  public PaymentTransactionEventData category(List<String> category) {
    this.category = category;
    return this;
  }

  public PaymentTransactionEventData addCategoryItem(String categoryItem) {
    if (this.category == null) {
      this.category = new ArrayList<>();
    }
    this.category.add(categoryItem);
    return this;
  }

   /**
   * A custom transaction category for you to identify your transfers more easily.
   * @return category
  **/
  @javax.annotation.Nullable
  public List<String> getCategory() {
    return category;
  }

  public void setCategory(List<String> category) {
    this.category = category;
  }


  public PaymentTransactionEventData description(String description) {
    this.description = description;
    return this;
  }

   /**
   * The description for your transaction.
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public PaymentTransactionEventData isLoop(Boolean isLoop) {
    this.isLoop = isLoop;
    return this;
  }

   /**
   * Whether the transaction was executed as a [Cobo Loop](https://manuals.cobo.com/en/portal/custodial-wallets/cobo-loop) transfer. - &#x60;true&#x60;: The transaction was executed as a Cobo Loop transfer. - &#x60;false&#x60;: The transaction was not executed as a Cobo Loop transfer. 
   * @return isLoop
  **/
  @javax.annotation.Nullable
  public Boolean getIsLoop() {
    return isLoop;
  }

  public void setIsLoop(Boolean isLoop) {
    this.isLoop = isLoop;
  }


  public PaymentTransactionEventData coboCategory(List<String> coboCategory) {
    this.coboCategory = coboCategory;
    return this;
  }

  public PaymentTransactionEventData addCoboCategoryItem(String coboCategoryItem) {
    if (this.coboCategory == null) {
      this.coboCategory = new ArrayList<>();
    }
    this.coboCategory.add(coboCategoryItem);
    return this;
  }

   /**
   * The transaction category defined by Cobo. Possible values include:  - &#x60;AutoSweep&#x60;: An auto-sweep transaction. - &#x60;AutoFueling&#x60;: A transaction where Fee Station pays transaction fees to an address within your wallet. - &#x60;AutoFuelingRefund&#x60;: A refund for an auto-fueling transaction. - &#x60;SafeTxMessage&#x60;: A message signing transaction to authorize a Smart Contract Wallet (Safe\\{Wallet\\}) transaction. - &#x60;BillPayment&#x60;: A transaction to pay Cobo bills through Fee Station. - &#x60;BillRefund&#x60;: A refund for a previously made bill payment. - &#x60;CommissionFeeCharge&#x60;: A transaction to charge commission fees via Fee Station. - &#x60;CommissionFeeRefund&#x60;: A refund of previously charged commission fees. 
   * @return coboCategory
  **/
  @javax.annotation.Nullable
  public List<String> getCoboCategory() {
    return coboCategory;
  }

  public void setCoboCategory(List<String> coboCategory) {
    this.coboCategory = coboCategory;
  }


  public PaymentTransactionEventData extra(List<String> extra) {
    this.extra = extra;
    return this;
  }

  public PaymentTransactionEventData addExtraItem(String extraItem) {
    if (this.extra == null) {
      this.extra = new ArrayList<>();
    }
    this.extra.add(extraItem);
    return this;
  }

   /**
   * A list of JSON-encoded strings containing structured, business-specific extra information for the transaction. Each item corresponds to a specific data type, indicated by the &#x60;extra_type&#x60; field in the JSON object (for example, \&quot;BabylonBusinessInfo\&quot;, \&quot;BtcAddressInfo\&quot;). 
   * @return extra
  **/
  @javax.annotation.Nullable
  public List<String> getExtra() {
    return extra;
  }

  public void setExtra(List<String> extra) {
    this.extra = extra;
  }


  public PaymentTransactionEventData fuelingInfo(TransactionFuelingInfo fuelingInfo) {
    this.fuelingInfo = fuelingInfo;
    return this;
  }

   /**
   * Get fuelingInfo
   * @return fuelingInfo
  **/
  @javax.annotation.Nullable
  public TransactionFuelingInfo getFuelingInfo() {
    return fuelingInfo;
  }

  public void setFuelingInfo(TransactionFuelingInfo fuelingInfo) {
    this.fuelingInfo = fuelingInfo;
  }


  public PaymentTransactionEventData createdTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
    return this;
  }

   /**
   * The time when the transaction was created, in Unix timestamp format, measured in milliseconds.
   * @return createdTimestamp
  **/
  @javax.annotation.Nonnull
  public Long getCreatedTimestamp() {
    return createdTimestamp;
  }

  public void setCreatedTimestamp(Long createdTimestamp) {
    this.createdTimestamp = createdTimestamp;
  }


  public PaymentTransactionEventData updatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
    return this;
  }

   /**
   * The time when the transaction was updated, in Unix timestamp format, measured in milliseconds.
   * @return updatedTimestamp
  **/
  @javax.annotation.Nonnull
  public Long getUpdatedTimestamp() {
    return updatedTimestamp;
  }

  public void setUpdatedTimestamp(Long updatedTimestamp) {
    this.updatedTimestamp = updatedTimestamp;
  }


  public PaymentTransactionEventData acquiringType(AcquiringType acquiringType) {
    this.acquiringType = acquiringType;
    return this;
  }

   /**
   * Get acquiringType
   * @return acquiringType
  **/
  @javax.annotation.Nonnull
  public AcquiringType getAcquiringType() {
    return acquiringType;
  }

  public void setAcquiringType(AcquiringType acquiringType) {
    this.acquiringType = acquiringType;
  }


  public PaymentTransactionEventData orderId(String orderId) {
    this.orderId = orderId;
    return this;
  }

   /**
   * The pay-in order ID.
   * @return orderId
  **/
  @javax.annotation.Nullable
  public String getOrderId() {
    return orderId;
  }

  public void setOrderId(String orderId) {
    this.orderId = orderId;
  }


  public PaymentTransactionEventData pspOrderCode(String pspOrderCode) {
    this.pspOrderCode = pspOrderCode;
    return this;
  }

   /**
   * A unique reference code assigned by the developer to identify this order in their system.
   * @return pspOrderCode
  **/
  @javax.annotation.Nullable
  public String getPspOrderCode() {
    return pspOrderCode;
  }

  public void setPspOrderCode(String pspOrderCode) {
    this.pspOrderCode = pspOrderCode;
  }


  public PaymentTransactionEventData payerId(String payerId) {
    this.payerId = payerId;
    return this;
  }

   /**
   * A unique identifier assigned by Cobo to track and identify individual payers.
   * @return payerId
  **/
  @javax.annotation.Nullable
  public String getPayerId() {
    return payerId;
  }

  public void setPayerId(String payerId) {
    this.payerId = payerId;
  }


  public PaymentTransactionEventData customPayerId(String customPayerId) {
    this.customPayerId = customPayerId;
    return this;
  }

   /**
   * A unique identifier assigned by the developer to track and identify individual payers in their system.
   * @return customPayerId
  **/
  @javax.annotation.Nullable
  public String getCustomPayerId() {
    return customPayerId;
  }

  public void setCustomPayerId(String customPayerId) {
    this.customPayerId = customPayerId;
  }

  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the PaymentTransactionEventData instance itself
   */
  public PaymentTransactionEventData putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaymentTransactionEventData paymentTransactionEventData = (PaymentTransactionEventData) o;
    return Objects.equals(this.dataType, paymentTransactionEventData.dataType) &&
        Objects.equals(this.transactionId, paymentTransactionEventData.transactionId) &&
        Objects.equals(this.coboId, paymentTransactionEventData.coboId) &&
        Objects.equals(this.requestId, paymentTransactionEventData.requestId) &&
        Objects.equals(this.walletId, paymentTransactionEventData.walletId) &&
        Objects.equals(this.type, paymentTransactionEventData.type) &&
        Objects.equals(this.status, paymentTransactionEventData.status) &&
        Objects.equals(this.subStatus, paymentTransactionEventData.subStatus) &&
        Objects.equals(this.failedReason, paymentTransactionEventData.failedReason) &&
        Objects.equals(this.chainId, paymentTransactionEventData.chainId) &&
        Objects.equals(this.tokenId, paymentTransactionEventData.tokenId) &&
        Objects.equals(this.assetId, paymentTransactionEventData.assetId) &&
        Objects.equals(this.source, paymentTransactionEventData.source) &&
        Objects.equals(this.destination, paymentTransactionEventData.destination) &&
        Objects.equals(this.result, paymentTransactionEventData.result) &&
        Objects.equals(this.fee, paymentTransactionEventData.fee) &&
        Objects.equals(this.initiator, paymentTransactionEventData.initiator) &&
        Objects.equals(this.initiatorType, paymentTransactionEventData.initiatorType) &&
        Objects.equals(this.confirmedNum, paymentTransactionEventData.confirmedNum) &&
        Objects.equals(this.confirmingThreshold, paymentTransactionEventData.confirmingThreshold) &&
        Objects.equals(this.transactionHash, paymentTransactionEventData.transactionHash) &&
        Objects.equals(this.blockInfo, paymentTransactionEventData.blockInfo) &&
        Objects.equals(this.rawTxInfo, paymentTransactionEventData.rawTxInfo) &&
        Objects.equals(this.replacement, paymentTransactionEventData.replacement) &&
        Objects.equals(this.category, paymentTransactionEventData.category) &&
        Objects.equals(this.description, paymentTransactionEventData.description) &&
        Objects.equals(this.isLoop, paymentTransactionEventData.isLoop) &&
        Objects.equals(this.coboCategory, paymentTransactionEventData.coboCategory) &&
        Objects.equals(this.extra, paymentTransactionEventData.extra) &&
        Objects.equals(this.fuelingInfo, paymentTransactionEventData.fuelingInfo) &&
        Objects.equals(this.createdTimestamp, paymentTransactionEventData.createdTimestamp) &&
        Objects.equals(this.updatedTimestamp, paymentTransactionEventData.updatedTimestamp) &&
        Objects.equals(this.acquiringType, paymentTransactionEventData.acquiringType) &&
        Objects.equals(this.orderId, paymentTransactionEventData.orderId) &&
        Objects.equals(this.pspOrderCode, paymentTransactionEventData.pspOrderCode) &&
        Objects.equals(this.payerId, paymentTransactionEventData.payerId) &&
        Objects.equals(this.customPayerId, paymentTransactionEventData.customPayerId)&&
        Objects.equals(this.additionalProperties, paymentTransactionEventData.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataType, transactionId, coboId, requestId, walletId, type, status, subStatus, failedReason, chainId, tokenId, assetId, source, destination, result, fee, initiator, initiatorType, confirmedNum, confirmingThreshold, transactionHash, blockInfo, rawTxInfo, replacement, category, description, isLoop, coboCategory, extra, fuelingInfo, createdTimestamp, updatedTimestamp, acquiringType, orderId, pspOrderCode, payerId, customPayerId, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaymentTransactionEventData {\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    transactionId: ").append(toIndentedString(transactionId)).append("\n");
    sb.append("    coboId: ").append(toIndentedString(coboId)).append("\n");
    sb.append("    requestId: ").append(toIndentedString(requestId)).append("\n");
    sb.append("    walletId: ").append(toIndentedString(walletId)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    subStatus: ").append(toIndentedString(subStatus)).append("\n");
    sb.append("    failedReason: ").append(toIndentedString(failedReason)).append("\n");
    sb.append("    chainId: ").append(toIndentedString(chainId)).append("\n");
    sb.append("    tokenId: ").append(toIndentedString(tokenId)).append("\n");
    sb.append("    assetId: ").append(toIndentedString(assetId)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    fee: ").append(toIndentedString(fee)).append("\n");
    sb.append("    initiator: ").append(toIndentedString(initiator)).append("\n");
    sb.append("    initiatorType: ").append(toIndentedString(initiatorType)).append("\n");
    sb.append("    confirmedNum: ").append(toIndentedString(confirmedNum)).append("\n");
    sb.append("    confirmingThreshold: ").append(toIndentedString(confirmingThreshold)).append("\n");
    sb.append("    transactionHash: ").append(toIndentedString(transactionHash)).append("\n");
    sb.append("    blockInfo: ").append(toIndentedString(blockInfo)).append("\n");
    sb.append("    rawTxInfo: ").append(toIndentedString(rawTxInfo)).append("\n");
    sb.append("    replacement: ").append(toIndentedString(replacement)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    isLoop: ").append(toIndentedString(isLoop)).append("\n");
    sb.append("    coboCategory: ").append(toIndentedString(coboCategory)).append("\n");
    sb.append("    extra: ").append(toIndentedString(extra)).append("\n");
    sb.append("    fuelingInfo: ").append(toIndentedString(fuelingInfo)).append("\n");
    sb.append("    createdTimestamp: ").append(toIndentedString(createdTimestamp)).append("\n");
    sb.append("    updatedTimestamp: ").append(toIndentedString(updatedTimestamp)).append("\n");
    sb.append("    acquiringType: ").append(toIndentedString(acquiringType)).append("\n");
    sb.append("    orderId: ").append(toIndentedString(orderId)).append("\n");
    sb.append("    pspOrderCode: ").append(toIndentedString(pspOrderCode)).append("\n");
    sb.append("    payerId: ").append(toIndentedString(payerId)).append("\n");
    sb.append("    customPayerId: ").append(toIndentedString(customPayerId)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("data_type");
    openapiFields.add("transaction_id");
    openapiFields.add("cobo_id");
    openapiFields.add("request_id");
    openapiFields.add("wallet_id");
    openapiFields.add("type");
    openapiFields.add("status");
    openapiFields.add("sub_status");
    openapiFields.add("failed_reason");
    openapiFields.add("chain_id");
    openapiFields.add("token_id");
    openapiFields.add("asset_id");
    openapiFields.add("source");
    openapiFields.add("destination");
    openapiFields.add("result");
    openapiFields.add("fee");
    openapiFields.add("initiator");
    openapiFields.add("initiator_type");
    openapiFields.add("confirmed_num");
    openapiFields.add("confirming_threshold");
    openapiFields.add("transaction_hash");
    openapiFields.add("block_info");
    openapiFields.add("raw_tx_info");
    openapiFields.add("replacement");
    openapiFields.add("category");
    openapiFields.add("description");
    openapiFields.add("is_loop");
    openapiFields.add("cobo_category");
    openapiFields.add("extra");
    openapiFields.add("fueling_info");
    openapiFields.add("created_timestamp");
    openapiFields.add("updated_timestamp");
    openapiFields.add("acquiring_type");
    openapiFields.add("order_id");
    openapiFields.add("psp_order_code");
    openapiFields.add("payer_id");
    openapiFields.add("custom_payer_id");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("data_type");
    openapiRequiredFields.add("transaction_id");
    openapiRequiredFields.add("wallet_id");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("source");
    openapiRequiredFields.add("destination");
    openapiRequiredFields.add("initiator_type");
    openapiRequiredFields.add("created_timestamp");
    openapiRequiredFields.add("updated_timestamp");
    openapiRequiredFields.add("acquiring_type");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to PaymentTransactionEventData
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PaymentTransactionEventData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PaymentTransactionEventData is not found in the empty JSON string", PaymentTransactionEventData.openapiRequiredFields.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : PaymentTransactionEventData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("data_type").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `data_type` to be a primitive type in the JSON string but got `%s`", jsonObj.get("data_type").toString()));
      }
      // validate the required field `data_type`
      DataTypeEnum.validateJsonElement(jsonObj.get("data_type"));
      if (!jsonObj.get("transaction_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_id").toString()));
      }
      if ((jsonObj.get("cobo_id") != null && !jsonObj.get("cobo_id").isJsonNull()) && !jsonObj.get("cobo_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `cobo_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("cobo_id").toString()));
      }
      if ((jsonObj.get("request_id") != null && !jsonObj.get("request_id").isJsonNull()) && !jsonObj.get("request_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `request_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("request_id").toString()));
      }
      if (!jsonObj.get("wallet_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `wallet_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("wallet_id").toString()));
      }
      // validate the optional field `type`
      if (jsonObj.get("type") != null && !jsonObj.get("type").isJsonNull()) {
        TransactionType.validateJsonElement(jsonObj.get("type"));
      }
      // validate the required field `status`
      TransactionStatus.validateJsonElement(jsonObj.get("status"));
      // validate the optional field `sub_status`
      if (jsonObj.get("sub_status") != null && !jsonObj.get("sub_status").isJsonNull()) {
        TransactionSubStatus.validateJsonElement(jsonObj.get("sub_status"));
      }
      if ((jsonObj.get("failed_reason") != null && !jsonObj.get("failed_reason").isJsonNull()) && !jsonObj.get("failed_reason").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `failed_reason` to be a primitive type in the JSON string but got `%s`", jsonObj.get("failed_reason").toString()));
      }
      if ((jsonObj.get("chain_id") != null && !jsonObj.get("chain_id").isJsonNull()) && !jsonObj.get("chain_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `chain_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("chain_id").toString()));
      }
      if ((jsonObj.get("token_id") != null && !jsonObj.get("token_id").isJsonNull()) && !jsonObj.get("token_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `token_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("token_id").toString()));
      }
      if ((jsonObj.get("asset_id") != null && !jsonObj.get("asset_id").isJsonNull()) && !jsonObj.get("asset_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `asset_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("asset_id").toString()));
      }
      // validate the required field `source`
      TransactionSource.validateJsonElement(jsonObj.get("source"));
      // validate the required field `destination`
      TransactionDestination.validateJsonElement(jsonObj.get("destination"));
      // validate the optional field `result`
      if (jsonObj.get("result") != null && !jsonObj.get("result").isJsonNull()) {
        TransactionResult.validateJsonElement(jsonObj.get("result"));
      }
      // validate the optional field `fee`
      if (jsonObj.get("fee") != null && !jsonObj.get("fee").isJsonNull()) {
        TransactionFee.validateJsonElement(jsonObj.get("fee"));
      }
      if ((jsonObj.get("initiator") != null && !jsonObj.get("initiator").isJsonNull()) && !jsonObj.get("initiator").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `initiator` to be a primitive type in the JSON string but got `%s`", jsonObj.get("initiator").toString()));
      }
      // validate the required field `initiator_type`
      TransactionInitiatorType.validateJsonElement(jsonObj.get("initiator_type"));
      if ((jsonObj.get("transaction_hash") != null && !jsonObj.get("transaction_hash").isJsonNull()) && !jsonObj.get("transaction_hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `transaction_hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("transaction_hash").toString()));
      }
      // validate the optional field `block_info`
      if (jsonObj.get("block_info") != null && !jsonObj.get("block_info").isJsonNull()) {
        TransactionBlockInfo.validateJsonElement(jsonObj.get("block_info"));
      }
      // validate the optional field `raw_tx_info`
      if (jsonObj.get("raw_tx_info") != null && !jsonObj.get("raw_tx_info").isJsonNull()) {
        TransactionRawTxInfo.validateJsonElement(jsonObj.get("raw_tx_info"));
      }
      // validate the optional field `replacement`
      if (jsonObj.get("replacement") != null && !jsonObj.get("replacement").isJsonNull()) {
        TransactionReplacement.validateJsonElement(jsonObj.get("replacement"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull() && !jsonObj.get("category").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `category` to be an array in the JSON string but got `%s`", jsonObj.get("category").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("cobo_category") != null && !jsonObj.get("cobo_category").isJsonNull() && !jsonObj.get("cobo_category").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `cobo_category` to be an array in the JSON string but got `%s`", jsonObj.get("cobo_category").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("extra") != null && !jsonObj.get("extra").isJsonNull() && !jsonObj.get("extra").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `extra` to be an array in the JSON string but got `%s`", jsonObj.get("extra").toString()));
      }
      // validate the optional field `fueling_info`
      if (jsonObj.get("fueling_info") != null && !jsonObj.get("fueling_info").isJsonNull()) {
        TransactionFuelingInfo.validateJsonElement(jsonObj.get("fueling_info"));
      }
      // validate the required field `acquiring_type`
      AcquiringType.validateJsonElement(jsonObj.get("acquiring_type"));
      if ((jsonObj.get("order_id") != null && !jsonObj.get("order_id").isJsonNull()) && !jsonObj.get("order_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `order_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("order_id").toString()));
      }
      if ((jsonObj.get("psp_order_code") != null && !jsonObj.get("psp_order_code").isJsonNull()) && !jsonObj.get("psp_order_code").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `psp_order_code` to be a primitive type in the JSON string but got `%s`", jsonObj.get("psp_order_code").toString()));
      }
      if ((jsonObj.get("payer_id") != null && !jsonObj.get("payer_id").isJsonNull()) && !jsonObj.get("payer_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `payer_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("payer_id").toString()));
      }
      if ((jsonObj.get("custom_payer_id") != null && !jsonObj.get("custom_payer_id").isJsonNull()) && !jsonObj.get("custom_payer_id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `custom_payer_id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("custom_payer_id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PaymentTransactionEventData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PaymentTransactionEventData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PaymentTransactionEventData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PaymentTransactionEventData.class));

       return (TypeAdapter<T>) new TypeAdapter<PaymentTransactionEventData>() {
           @Override
           public void write(JsonWriter out, PaymentTransactionEventData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additional properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() == null)
                   obj.addProperty(entry.getKey(), (String) null);
                 else if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   JsonElement jsonElement = gson.toJsonTree(entry.getValue());
                   if (jsonElement.isJsonArray()) {
                     obj.add(entry.getKey(), jsonElement.getAsJsonArray());
                   } else {
                     obj.add(entry.getKey(), jsonElement.getAsJsonObject());
                   }
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public PaymentTransactionEventData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             JsonObject jsonObj = jsonElement.getAsJsonObject();
             // store additional fields in the deserialized instance
             PaymentTransactionEventData instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of PaymentTransactionEventData given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of PaymentTransactionEventData
  * @throws IOException if the JSON string is invalid with respect to PaymentTransactionEventData
  */
  public static PaymentTransactionEventData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PaymentTransactionEventData.class);
  }

 /**
  * Convert an instance of PaymentTransactionEventData to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

